<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Integer Add/Subtract – Vectors</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --border:#e5e7eb;
      --shadow: 0 10px 25px rgba(0,0,0,.08);
      --radius: 18px;

      --line:#111827;
      --tick:#111827;

      --pos:#16a34a; /* green */
      --neg:#dc2626; /* red  */
      --eq:#2563eb;  /* blue for = result */
      --hi:#fde68a;  /* yellow highlight */

      --ansGreen:#16a34a;
      --ansGreenSoft: rgba(22,163,74,.16);
      --ansGreenBorder: rgba(22,163,74,.35);

      --footer-h: 44px;

      --animMs: 2000;

      /* arrows */
      --arrowW: 4;
      --dash: 16;
      --gap: 14;

      --headW: 6;
      --headH: 6;

      --pad: 3;

      /* ✅ EASY PNG SIZE TWEAK:
         Change this one value to resize the stick figure quickly. */
      --personW: 92px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: var(--bg);
      color: var(--ink);
      padding-bottom: var(--footer-h);
    }

    .wrap{ max-width: 1100px; margin: 22px auto 40px; padding: 0 16px; }
    .card{
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 14px;
      position: relative;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }

    .brandBack{
      display:inline-flex;
      align-items:center;
      gap:10px;
      text-decoration:none;
      color: var(--ink);
      font-weight: 950;
      border: 1px solid var(--border);
      background:#fff;
      padding: 8px 12px;
      border-radius: 999px;
      box-shadow: 0 10px 22px rgba(0,0,0,.06);
      user-select:none;
      white-space: nowrap;
    }
    .brandBack img{ height: 26px; width:auto; display:block; }
    .brandBack span{ font-size: 13px; letter-spacing:.1px; }

    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    button{
      border:none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 900;
      cursor:pointer;
      background:#f3f4f6;
      color:#111827;
      transition: transform .04s ease, filter .15s ease, opacity .2s ease;
      user-select:none;
    }
    button:active{ transform: scale(.98); }
    button.primary{ background: #2563eb; color:#fff; }
    button.danger{ background:#fee2e2; color:#991b1b; }
    button.ghost{ background:#f3f4f6; color:#111827; }

    .qRowUnder{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 12px;
      margin: 8px 0 10px;
      flex-wrap:wrap;
    }
    .qLabel{
      font-weight: 950;
      color: var(--ink);
      font-size: 16px;
      white-space: nowrap;
    }
    .qBox{
      border: 2px solid #111827;
      border-radius: 16px;
      padding: 10px 14px;
      font-weight: 950;
      font-size: 26px;
      letter-spacing: .2px;
      background:#fff;
      min-width: 240px;
      text-align:center;
      line-height: 1.15;
    }

    .qLine{ display:block; margin: 0; }

    .hl{
      background: var(--hi);
      border-radius: 10px;
      padding: 2px 6px;
      display:inline-block;
    }
    .eq{ color: var(--eq); font-weight: 950; }

    .ansPill{
      display:inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      background: rgba(37,99,235,.18);
      color: var(--eq);
      font-weight: 950;
      border: 2px solid transparent;
    }
    .ansPill.final{
      background: var(--ansGreenSoft);
      color: #0f3d22;
      border-color: var(--ansGreenBorder);
      font-size: 30px;           /* slightly larger */
      padding: 4px 12px;
    }

    .stage{
      margin-top: 8px;
      padding: 12px 12px 18px;
      border-radius: 16px;
      background: linear-gradient(180deg,#ffffff, #f9fafb);
      border: 1px solid #e5e7eb;
      overflow:hidden;
      position: relative;
      min-height: 540px;
    }

    .svgwrap{ width:100%; height: 440px; display:block; }

    .personLayer{
      position:absolute;
      left:0; top:0; right:0; bottom:0;
      pointer-events:none;
    }
    .person{
      position:absolute;
      width: var(--personW);
      height: auto;
      transform: translate(-50%, -50%);
      top: 120px;
      left: 50%;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.12));
    }

    .stageActions{
      position: absolute;
      left: 14px;
      right: 14px;
      bottom: 14px;
      display:flex;
      justify-content:center;
      gap: 18px;
      pointer-events:none;
    }
    .navBtn{
      pointer-events:auto;
      border-radius: 999px;
      padding: 12px 18px;
      font-weight: 950;
      box-shadow: 0 12px 24px rgba(0,0,0,.10);
      min-width: 60px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
    }
    .navBtn[disabled]{ opacity: .45; cursor:not-allowed; transform:none; }

    .hintRow{
      margin-top: 10px;
      text-align:center;
      font-size: 12px;
      color: var(--muted);
      font-weight: 850;
    }

    .mmtFooter{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      height: var(--footer-h);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 12px;
      background: rgba(255,255,255,.92);
      border-top: 1px solid rgba(229,231,235,.95);
      backdrop-filter: blur(8px);
      z-index: 500;
      font-weight: 900;
      color: #111827;
      text-align:center;
      font-size: 13px;
    }
    .mmtFooter a{ color: #2563eb; text-decoration:none; font-weight: 950; }
    .mmtFooter a:hover{ text-decoration: underline; }

    .baseline{ stroke: var(--line); stroke-width: 7; stroke-linecap: round; }
    .tickMajor{ stroke: var(--tick); stroke-width: 7; stroke-linecap: round; }
    .tickUnit{
      stroke: rgba(17,24,39,.40);
      stroke-width: 3;
      stroke-linecap: round;
      opacity: 1;
    }

    .dot{ fill: #111827; opacity: 0.92; }
    .dot.zero{ opacity: 0.85; }

    .label{
      font-size: 26px;
      font-weight: 950;
      fill: #111827;
    }
    .label.final{
      fill: #0f3d22;
    }

    /* green highlight behind the RESULT label (number line) */
    .resHalo{
      fill: rgba(34,197,94,.20);
      stroke: rgba(34,197,94,.35);
      stroke-width: 3;
      display: none;
    }

    .arrowPath{
      fill: none;
      stroke-width: var(--arrowW);
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: var(--dash) var(--gap);
    }
    .arrowLabel{
      font-size: 30px;
      font-weight: 950;
    }

    .trackerDot{
      fill: #111827;
      opacity: 0;
      transition: opacity .12s ease;
    }

    /* ---------- Teacher settings modal ---------- */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(17,24,39,.45);
      backdrop-filter: blur(6px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 999;
      padding: 18px;
    }
    .modal{
      width: min(520px, 100%);
      background:#fff;
      border-radius: 18px;
      box-shadow: 0 22px 60px rgba(0,0,0,.22);
      border: 1px solid rgba(229,231,235,.9);
      overflow:hidden;
    }
    .modalHeader{
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(229,231,235,.9);
      background: linear-gradient(180deg,#fff,#f9fafb);
    }
    .modalTitle{
      font-weight: 950;
      font-size: 16px;
    }
    .modalBody{
      padding: 14px 16px 6px;
    }
    .opt{
      display:flex;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid rgba(229,231,235,.9);
      border-radius: 14px;
      margin-bottom: 10px;
      align-items:flex-start;
    }
    .opt input{ margin-top: 3px; }
    .opt b{ display:block; font-weight: 950; }
    .opt small{ color: var(--muted); font-weight: 800; display:block; margin-top: 2px; line-height: 1.25; }
    .modalFooter{
      padding: 12px 16px 14px;
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      border-top: 1px solid rgba(229,231,235,.9);
      background:#fff;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <a class="brandBack" href="https://www.millsmathstools.au" aria-label="Back to Mills Maths Tools">
          <img src="mmt.png" alt="MMT logo">
          <span>Back to Mills Maths Tools</span>
        </a>

        <div class="btnrow">
          <button id="teacherBtn" class="ghost" title="Teacher settings">Teacher settings</button>
          <button id="resetBtn" class="danger" title="Reset (R)">Reset</button>
          <button id="newBtn" class="primary" title="New question (Space)">New Q</button>
        </div>
      </div>

      <div class="qRowUnder" aria-label="Question">
        <div class="qLabel">Question:</div>
        <div id="qBox" class="qBox">
          <!-- ✅ simplified second line removed -->
          <span id="qMain" class="qLine">—</span>
        </div>
      </div>

      <div class="stage">
        <svg id="svg" class="svgwrap" viewBox="0 0 1000 440" role="img" aria-label="number line"></svg>

        <div class="personLayer">
          <img id="personImg" class="person" src="still.png" alt="person">
        </div>

        <div class="stageActions">
          <button id="backBtn" class="navBtn" title="Back (←)" aria-label="Back">◀</button>
          <button id="fwdBtn" class="navBtn primary" title="Forward (→ / Enter)" aria-label="Forward">▶</button>
        </div>
      </div>

      <div class="hintRow">
        Shortcuts: ← / → step · Enter = skip/next · Space = New Q · R = Reset
      </div>
    </div>
  </div>

  <div class="mmtFooter">
    This tool and more can be found at&nbsp;
    <a href="https://www.millsmathstools.au">www.millsmathstools.au</a>
  </div>

  <!-- Teacher settings modal -->
  <div id="modalOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-label="Teacher settings">
    <div class="modal">
      <div class="modalHeader">
        <div class="modalTitle">Teacher settings</div>
        <button id="closeModalBtn" class="ghost" aria-label="Close">✕</button>
      </div>

      <div class="modalBody">
        <div class="opt">
          <input type="radio" name="mode" id="modeSweet" value="sweet">
          <label for="modeSweet">
            <b>Sweet (default)</b>
            <small>Integers from −20 to 20</small>
          </label>
        </div>

        <div class="opt">
          <input type="radio" name="mode" id="modeMild" value="mild">
          <label for="modeMild">
            <b>Mild</b>
            <small>Integers from −50 to 50</small>
          </label>
        </div>

        <div class="opt">
          <input type="radio" name="mode" id="modeMedium" value="medium">
          <label for="modeMedium">
            <b>Medium</b>
            <small>Integers from −100 to 100</small>
          </label>
        </div>

        <div class="opt">
          <input type="radio" name="mode" id="modeSpicy" value="spicy">
          <label for="modeSpicy">
            <b>Spicy</b>
            <small>Range −100 to 100, values to 1dp in 0.5 steps (… −2.5, −2.0, −1.5, …)</small>
          </label>
        </div>
      </div>

      <div class="modalFooter">
        <button id="cancelModalBtn" class="ghost">Cancel</button>
        <button id="applyModalBtn" class="primary">Apply</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const PAD = 3;
  const ANIM_MS = 2000;

  const SPRITES = {
    still: "still.png",
    right: ["walk-right-1.png", "walk-right-2.png"],
    left:  ["walk-left-1.png",  "walk-left-2.png"]
  };

  const MODES = {
    sweet:  { min:-20,  max: 20,  step:1,   decimals:false },
    mild:   { min:-50,  max: 50,  step:1,   decimals:false },
    medium: { min:-100, max:100,  step:1,   decimals:false },
    spicy:  { min:-100, max:100,  step:0.5, decimals:true  }
  };

  const LS_KEY = "mmt_vectors_mode_v1";

  const svg = document.getElementById("svg");
  const qMain = document.getElementById("qMain");
  const personImg = document.getElementById("personImg");

  const newBtn = document.getElementById("newBtn");
  const resetBtn = document.getElementById("resetBtn");
  const backBtn = document.getElementById("backBtn");
  const fwdBtn  = document.getElementById("fwdBtn");

  const teacherBtn = document.getElementById("teacherBtn");
  const modalOverlay = document.getElementById("modalOverlay");
  const closeModalBtn = document.getElementById("closeModalBtn");
  const cancelModalBtn = document.getElementById("cancelModalBtn");
  const applyModalBtn = document.getElementById("applyModalBtn");

  const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const abs = Math.abs;
  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

  let settings = { mode: "sweet" };

  function loadSettings(){
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return;
    try{
      const s = JSON.parse(raw);
      if (s && MODES[s.mode]) settings.mode = s.mode;
    }catch(_){}
  }
  function saveSettings(){
    localStorage.setItem(LS_KEY, JSON.stringify(settings));
  }

  function cfg(){ return MODES[settings.mode] || MODES.sweet; }

  function fmtNum(n){
    // avoid "-0" visual noise
    const z = (Math.abs(n) < 1e-9) ? 0 : n;
    return cfg().decimals ? z.toFixed(1) : String(Math.trunc(z));
  }

  function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

  function el(name, attrs={}, children=[]){
    const n = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
    for (const c of children) n.appendChild(c);
    return n;
  }
  function textNode(str, attrs={}){
    const t = el("text", attrs);
    t.textContent = str;
    return t;
  }

  function fmtSignedVector(n){
    // label on arrow: negatives show "-", positives show without "+"
    return (n < 0) ? fmtNum(n) : fmtNum(abs(n));
  }

  function questionHTML(a, op, b, highlightPart){
    const opChar = (op === "+") ? "+" : "−";
    const aStr = fmtNum(a);
    const bStr = (b < 0) ? `(${fmtNum(b)})` : `(+${fmtNum(b)})`;
    const wrap = (txt, which) => (highlightPart === which) ? `<span class="hl">${txt}</span>` : txt;
    return `${wrap(aStr,"a")} ${wrap(opChar,"op")} ${wrap(bStr,"b")}`;
  }

  function setPersonStill(){ personImg.src = SPRITES.still; }
  function setPersonStaticFacingByOp(op){
    personImg.src = (op === "+") ? SPRITES.right[0] : SPRITES.left[0];
  }
  function spriteFramesForDirection(spriteDir){
    return (spriteDir === "+") ? SPRITES.right : SPRITES.left;
  }
  function setPersonX(viewX){
    const pct = (viewX / 1000) * 100;
    personImg.style.left = pct + "%";
  }

  // ---- Enter-to-skip animation ----
  let isAnimating = false;
  let animToken = null;
  function beginAnimToken(){
    animToken = { skip:false };
    isAnimating = true;
    return animToken;
  }
  function endAnimToken(){
    isAnimating = false;
    animToken = null;
  }
  function requestSkip(){
    if (animToken) animToken.skip = true;
  }

  let walkingTimer = null;
  function stopWalking(){
    if (walkingTimer) { clearInterval(walkingTimer); walkingTimer = null; }
  }
  function startWalking(spriteDir){
    stopWalking();
    const frames = spriteFramesForDirection(spriteDir);
    let i = 0;
    personImg.src = frames[0];
    walkingTimer = setInterval(() => {
      i = (i + 1) % frames.length;
      personImg.src = frames[i];
    }, 220);
  }

  function nonZeroRandStepped(){
    const { min, max, step } = cfg();
    const kMin = Math.round(min / step);
    const kMax = Math.round(max / step);
    for (let i=0;i<5000;i++){
      const k = randInt(kMin, kMax);
      if (k === 0) continue;
      const v = k * step;
      // guard against float weirdness
      return Math.round(v / step) * step;
    }
    return step;
  }

  function generateQuestion(){
    const { min, max } = cfg();
    for (let tries=0; tries<12000; tries++){
      const a = nonZeroRandStepped();
      const b = nonZeroRandStepped();
      const op = (Math.random() < 0.5) ? "+" : "-";
      const res = (op === "+") ? (a + b) : (a - b);
      if (res < min || res > max) continue;
      return { a, b, op, res };
    }
    return { a: 5, b: -3, op: "+", res: 2 };
  }

  function snapToStep(v, step, dir){
    // dir: "down" => floor, "up" => ceil
    const k = v / step;
    const snapped = (dir === "down") ? Math.floor(k) * step : Math.ceil(k) * step;
    return Math.round(snapped / step) * step;
  }

  function computeViewRange(a, res){
    const { min, max, step } = cfg();
    const lo = Math.min(0, a, res) - PAD;
    const hi = Math.max(0, a, res) + PAD;
    const vmin = clamp(snapToStep(lo, step, "down"), min, max);
    const vmax = clamp(snapToStep(hi, step, "up"),   min, max);
    // ensure span
    if (Math.abs(vmax - vmin) < step*2){
      const mid = (vmin + vmax)/2;
      return {
        vmin: clamp(snapToStep(mid - PAD, step, "down"), min, max),
        vmax: clamp(snapToStep(mid + PAD, step, "up"),   min, max)
      };
    }
    return { vmin, vmax };
  }

  let Q = null;
  let stepState = 0; // 0..4 now
  let refs = null;

  function buildScene(){
    clearSVG();
    refs = null;

    const { a, b, op, res } = Q;
    const { vmin, vmax } = computeViewRange(a, res);
    const { step: tickStep } = cfg();

    const left = 80, right = 920;

    const yLine = 325;
    const tickTop = yLine - 22;
    const yArrow1 = tickTop - 42;
    const yArrow2 = yArrow1 - 58; // master

    const tickBot = yLine + 22;
    const dotR = 10;
    const labelY = 405;

    const x = (v) => {
      const t = (v - vmin) / (vmax - vmin);
      return left + t * (right - left);
    };

    const defs = el("defs");

    // end marker (points along the path direction)
    const mkEnd = el("marker",{
      id:"arrowHeadSmall",
      markerWidth:"6",
      markerHeight:"6",
      refX:"6",
      refY:"3",
      orient:"auto",
      markerUnits:"strokeWidth",
      viewBox:"0 0 6 6"
    },[
      el("path",{ d:"M 0 0 L 6 3 L 0 6 z", fill:"currentColor" })
    ]);

    // start marker (FLIPPED)
    const mkStart = el("marker",{
      id:"arrowHeadStart",
      markerWidth:"6",
      markerHeight:"6",
      refX:"0",
      refY:"3",
      orient:"auto",
      markerUnits:"strokeWidth",
      viewBox:"0 0 6 6"
    },[
      el("path",{ d:"M 6 0 L 0 3 L 6 6 z", fill:"currentColor" })
    ]);

    defs.appendChild(mkEnd);
    defs.appendChild(mkStart);
    svg.appendChild(defs);

    svg.appendChild(el("line", { x1:left, y1:yLine, x2:right, y2:yLine, class:"baseline" }));

    const gTicks = el("g");
    const gUnit  = el("g");
    const gArrows= el("g");

    function addMajor(val, dotClass){
      const xi = x(val);

      const line = el("line",{ x1:xi, y1:tickTop, x2:xi, y2:tickBot, class:"tickMajor" });
      const dot  = el("circle",{ cx:xi, cy:yLine, r:dotR, class:`dot ${dotClass||""}`.trim() });

      // halo for result (drawn behind)
      const halo = el("circle",{ cx:xi, cy:labelY-18, r:"26", class:"resHalo" });

      const lbl = textNode(fmtNum(val), { x:xi, y:labelY, "text-anchor":"middle", class:"label" });

      gTicks.appendChild(line);
      gTicks.appendChild(dot);
      gTicks.appendChild(halo);
      gTicks.appendChild(lbl);

      return { x: xi, line, dot, halo, lbl, val };
    }

    // unit ticks (respect step: 1 or 0.5)
    const span = vmax - vmin;
    const nSteps = Math.round(span / tickStep);

    for (let i=0; i<=nSteps; i++){
      const v = vmin + i * tickStep;
      if (Math.abs(v) < 1e-9) continue; // skip 0
      const xi = x(v);
      gUnit.appendChild(el("line", { x1:xi, y1:yLine-12, x2:xi, y2:yLine+12, class:"tickUnit" }));
    }

    svg.appendChild(gUnit);
    svg.appendChild(gTicks);

    const major0  = addMajor(0, "zero");
    const majorA  = addMajor(a, "");
    const majorR  = addMajor(res, "");

    function makeArrow(x1, x2, y, color, labelText, headSide="end"){
      const attrs = { x1, y1:y, x2:x1, y2:y, class:"arrowPath" };
      if (headSide === "start") attrs["marker-start"] = "url(#arrowHeadStart)";
      else attrs["marker-end"] = "url(#arrowHeadSmall)";

      const path = el("line", attrs);
      path.style.stroke = color;
      path.style.color  = color;
      path.style.display = "none";

      const lx = (x1 + x2) / 2;
      const ly = y - 18;
      const label = textNode(labelText, { x:lx, y:ly, "text-anchor":"middle", class:"arrowLabel" });
      label.style.fill = color;
      label.style.display = "none";

      const tip = el("circle",{ cx:x1, cy:y, r:"6", class:"trackerDot" });
      tip.style.display = "none";

      gArrows.appendChild(path);
      gArrows.appendChild(label);
      gArrows.appendChild(tip);

      return { path, label, tip, x1, x2, y, color, headSide };
    }

    const x0 = major0.x;
    const xA = majorA.x;
    const xR = majorR.x;

    const colA = (a >= 0) ? "var(--pos)" : "var(--neg)";
    const colB = (b >= 0) ? "var(--pos)" : "var(--neg)";

    const disp2 = (op === "+") ? b : -b;
    const xEnd2 = x(a + disp2);

    const arrowA = makeArrow(x0, xA, yArrow1, colA, fmtSignedVector(a), "end");

    // subtraction ALWAYS reverses the arrowhead (walk back along the vector)
    const headSideB = (op === "-") ? "start" : "end";
    const arrowB = makeArrow(xA, xEnd2, yArrow2, colB, fmtSignedVector(b), headSideB);

    svg.appendChild(gArrows);

    // Hide ALL major stuff except 0 initially
    // We’ll control reveal manually (and now we can reveal result tick WITHOUT its label).
    const tickNodes = Array.from(gTicks.childNodes);

    // Order: for each addMajor: line, dot, halo, label  (4 nodes each)
    // major0: 0..3, majorA: 4..7, majorR: 8..11
    for (let i=4; i<tickNodes.length; i++){
      tickNodes[i].style.display = "none";
    }

    refs = {
      x0, xA, xR,
      arrowA, arrowB,
      tickNodes,
      majorA, majorR,
      showA: () => { for (let i=4; i<8; i++) tickNodes[i].style.display = ""; }, // show a line/dot/halo/label (halo unused unless you turn it on)
      showResTickOnly: () => { // show result line + dot ONLY
        tickNodes[8].style.display  = ""; // line
        tickNodes[9].style.display  = ""; // dot
        tickNodes[10].style.display = "none"; // halo
        tickNodes[11].style.display = "none"; // label
      },
      showResLabelAndHalo: () => {
        tickNodes[8].style.display  = "";
        tickNodes[9].style.display  = "";
        tickNodes[10].style.display = ""; // halo
        tickNodes[11].style.display = ""; // label
      },
      hideResLabelAndHalo: () => {
        tickNodes[10].style.display = "none";
        tickNodes[11].style.display = "none";
      }
    };

    // start position at 0
    setPersonX(x0);

    // ensure halo off until final
    majorR.halo.style.display = "none";
  }

  function showArrowLabel(arrow){ arrow.label.style.display = ""; }
  function hideArrow(arrow){
    arrow.path.style.display = "none";
    arrow.label.style.display = "none";
    arrow.tip.style.display = "none";
    arrow.tip.style.opacity = "0";
  }

  function snapArrowToEnd(arrow){
    const { path, tip, x1, x2, y } = arrow;
    path.style.display = "";
    tip.style.display  = "";
    tip.style.opacity  = "1";
    path.setAttribute("x1", String(x1));
    path.setAttribute("y1", String(y));
    path.setAttribute("x2", String(x2));
    path.setAttribute("y2", String(y));
    tip.setAttribute("cx", String(x2));
    tip.setAttribute("cy", String(y));
  }

  function animateLineArrow(arrow, durationMs, token){
    return new Promise((resolve) => {
      const { path, tip, x1, x2, y } = arrow;

      path.style.display = "";
      tip.style.display  = "";
      tip.style.opacity  = "1";

      const start = performance.now();

      function frame(now){
        if (token && token.skip){
          snapArrowToEnd(arrow);
          resolve();
          return;
        }

        const t = clamp((now - start) / durationMs, 0, 1);
        const eased = 1 - Math.pow(1 - t, 2);

        const cx = x1 + (x2 - x1) * eased;

        path.setAttribute("x1", String(x1));
        path.setAttribute("y1", String(y));
        path.setAttribute("x2", String(cx));
        path.setAttribute("y2", String(y));

        tip.setAttribute("cx", String(cx));
        tip.setAttribute("cy", String(y));

        if (t < 1){
          requestAnimationFrame(frame);
        } else {
          snapArrowToEnd(arrow);
          resolve();
        }
      }

      path.setAttribute("x2", String(x1));
      requestAnimationFrame(frame);
    });
  }

  function snapPersonTo(toX){
    stopWalking();
    setPersonX(toX);
    setPersonStill();
  }

  // moveDir controls motion, spriteDir controls which walk frames play.
  function movePerson(fromX, toX, moveDir, spriteDir, durationMs, token){
    return new Promise((resolve) => {
      startWalking(spriteDir);
      const start = performance.now();

      function frame(now){
        if (token && token.skip){
          snapPersonTo(toX);
          resolve();
          return;
        }

        const t = clamp((now - start) / durationMs, 0, 1);
        const eased = 1 - Math.pow(1 - t, 2);
        const cx = fromX + (toX - fromX) * eased;
        setPersonX(cx);

        if (t < 1){
          requestAnimationFrame(frame);
        } else {
          stopWalking();
          setPersonStill();
          resolve();
        }
      }
      requestAnimationFrame(frame);
    });
  }

  function setQuestionText(highlightPart=null){
    const { a, b, op } = Q;
    qMain.innerHTML = questionHTML(a, op, b, highlightPart);
  }

  function setAnswerShown(show){
    const { a, b, op, res } = Q;
    if (!show){
      qMain.innerHTML = questionHTML(a, op, b, null);
      return;
    }
    qMain.innerHTML = `${questionHTML(a, op, b, null)} <span class="eq">= <span class="ansPill final">${fmtNum(res)}</span></span>`;
  }

  function highlightResultOnNumberLine(show){
    if (!refs) return;
    if (!show){
      refs.majorR.halo.style.display = "none";
      refs.majorR.lbl.classList.remove("final");
      return;
    }
    refs.majorR.halo.style.display = "";
    refs.majorR.lbl.classList.add("final");
  }

  function updateNavButtons(){
    backBtn.disabled = (stepState <= 0);
    fwdBtn.disabled  = (stepState >= 4);
  }

  function goToStep0(){
    stepState = 0;
    setAnswerShown(false);
    setQuestionText(null);
    setPersonStill();
    setPersonX(refs.x0);
    hideArrow(refs.arrowA);
    hideArrow(refs.arrowB);

    // hide A and R
    for (let i=4; i<refs.tickNodes.length; i++){
      refs.tickNodes[i].style.display = "none";
    }

    // halo/label off
    highlightResultOnNumberLine(false);
    updateNavButtons();
  }

  async function doStep1(){
    stepState = 1;
    setAnswerShown(false);
    setQuestionText("a");
    refs.showA();

    showArrowLabel(refs.arrowA);

    const moveDir1   = (Q.a >= 0) ? "+" : "−";  // movement depends on sign
    const spriteDir1 = "+";                     // ALWAYS walk-right for first vector

    const token = beginAnimToken();
    try{
      await Promise.all([
        animateLineArrow(refs.arrowA, ANIM_MS, token),
        movePerson(refs.x0, refs.xA, moveDir1, spriteDir1, ANIM_MS, token)
      ]);
    } finally {
      endAnimToken();
    }

    updateNavButtons();
  }

  async function doStep2(){
    stepState = 2;
    setAnswerShown(false);
    setQuestionText("op");
    setPersonStaticFacingByOp(Q.op);
    updateNavButtons();
  }

  async function doStep3(){
    stepState = 3;
    setAnswerShown(false);
    setQuestionText("b");

    showArrowLabel(refs.arrowB);

    // show result tick ONLY (no label/halo yet)
    refs.showResTickOnly();

    const step2 = (Q.op === "+") ? Q.b : -Q.b;
    const moveDir  = (step2 >= 0) ? "+" : "−";

    // sprite direction depends ONLY on the operator (not the vector)
    const spriteDir = (Q.op === "+") ? "+" : "−";

    const token = beginAnimToken();
    try{
      await Promise.all([
        animateLineArrow(refs.arrowB, ANIM_MS, token),
        movePerson(refs.xA, refs.xR, moveDir, spriteDir, ANIM_MS, token)
      ]);
    } finally {
      endAnimToken();
    }

    // IMPORTANT: still NO answer labels here (you asked reveal 3 stays clean)
    refs.hideResLabelAndHalo();
    highlightResultOnNumberLine(false);

    updateNavButtons();
  }

  function doStep4(){
    stepState = 4;

    // now reveal answer in box and on number line
    setAnswerShown(true);
    refs.showResLabelAndHalo();
    highlightResultOnNumberLine(true);

    updateNavButtons();
  }

  async function stepForward(){
    if (stepState >= 4) return;
    if (stepState === 0) return doStep1();
    if (stepState === 1) return doStep2();
    if (stepState === 2) return doStep3();
    if (stepState === 3) return doStep4();
  }

  function stepBack(){
    if (stepState <= 0) return;
    const target = stepState - 1;

    buildScene();
    goToStep0();

    // rebuild to target state (snapped, no animations)
    if (target >= 1){
      setQuestionText("a");
      refs.showA();
      showArrowLabel(refs.arrowA);
      snapArrowToEnd(refs.arrowA);
      setPersonX(refs.xA);
      setPersonStill();
      stepState = 1;
    }
    if (target >= 2){
      setQuestionText("op");
      setPersonStaticFacingByOp(Q.op);
      stepState = 2;
    }
    if (target >= 3){
      setQuestionText("b");
      showArrowLabel(refs.arrowB);
      snapArrowToEnd(refs.arrowB);
      setPersonX(refs.xR);
      setPersonStill();

      refs.showResTickOnly();
      refs.hideResLabelAndHalo();
      highlightResultOnNumberLine(false);

      stepState = 3;
    }
    if (target >= 4){
      setAnswerShown(true);
      refs.showResLabelAndHalo();
      highlightResultOnNumberLine(true);
      stepState = 4;
    }

    updateNavButtons();
  }

  function newQuestion(){
    Q = generateQuestion();
    buildScene();
    goToStep0();
  }

  function resetQuestion(){
    buildScene();
    goToStep0();
  }

  // ---------- Teacher settings ----------
  function openModal(){
    modalOverlay.style.display = "flex";
    // set current checked
    const m = settings.mode;
    document.getElementById("modeSweet").checked  = (m === "sweet");
    document.getElementById("modeMild").checked   = (m === "mild");
    document.getElementById("modeMedium").checked = (m === "medium");
    document.getElementById("modeSpicy").checked  = (m === "spicy");
  }
  function closeModal(){
    modalOverlay.style.display = "none";
  }
  function getSelectedModeFromModal(){
    const picked = document.querySelector('input[name="mode"]:checked');
    return (picked && MODES[picked.value]) ? picked.value : settings.mode;
  }
  function applyModal(){
    const chosen = getSelectedModeFromModal();
    settings.mode = chosen;
    saveSettings();
    closeModal();
    newQuestion();
  }

  teacherBtn.addEventListener("click", openModal);
  closeModalBtn.addEventListener("click", closeModal);
  cancelModalBtn.addEventListener("click", closeModal);
  applyModalBtn.addEventListener("click", applyModal);
  modalOverlay.addEventListener("click", (e) => {
    if (e.target === modalOverlay) closeModal();
  });

  // ---------- controls ----------
  newBtn.addEventListener("click", () => newQuestion());
  resetBtn.addEventListener("click", () => resetQuestion());
  backBtn.addEventListener("click", () => stepBack());
  fwdBtn.addEventListener("click", () => {
    if (isAnimating) requestSkip();
    else stepForward();
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){
      e.preventDefault();
      if (isAnimating) requestSkip();
      else stepForward();
      return;
    }

    if (e.code === "Space"){ e.preventDefault(); newQuestion(); return; }
    if (e.key === "ArrowRight"){ e.preventDefault(); stepForward(); return; }
    if (e.key === "ArrowLeft"){ e.preventDefault(); stepBack(); return; }
    if (e.key.toLowerCase() === "r"){ e.preventDefault(); resetQuestion(); return; }
    if (e.key === "Escape" && modalOverlay.style.display === "flex"){ closeModal(); return; }
  });

  // init
  loadSettings();
  newQuestion();
})();
</script>
</body>
</html>
