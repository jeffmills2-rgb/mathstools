<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Integer Add/Subtract ‚Äì Vectors</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --border:#e5e7eb;
      --shadow: 0 10px 25px rgba(0,0,0,.08);
      --radius: 18px;

      --line:#111827;
      --tick:#111827;

      --pos:#16a34a; /* green */
      --neg:#dc2626; /* red  */
      --eq:#2563eb;  /* blue for = result */
      --hi:#fde68a;  /* yellow highlight */

      --ok:#16a34a;
      --okSoft: rgba(22,163,74,.22);

      --footer-h: 44px;

      --animMs: 2000;

      /* arrows */
      --arrowW: 4;
      --dash: 16;
      --gap: 14;

      --headW: 6;
      --headH: 6;

      --pad: 3;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: var(--bg);
      color: var(--ink);
      padding-bottom: var(--footer-h);
    }

    .wrap{ max-width: 1100px; margin: 22px auto 40px; padding: 0 16px; }
    .card{
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 14px;
      position: relative;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }

    .brandBack{
      display:inline-flex;
      align-items:center;
      gap:10px;
      text-decoration:none;
      color: var(--ink);
      font-weight: 950;
      border: 1px solid var(--border);
      background:#fff;
      padding: 8px 12px;
      border-radius: 999px;
      box-shadow: 0 10px 22px rgba(0,0,0,.06);
      user-select:none;
      white-space: nowrap;
    }
    .brandBack img{ height: 26px; width:auto; display:block; }
    .brandBack span{ font-size: 13px; letter-spacing:.1px; }

    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    button{
      border:none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 900;
      cursor:pointer;
      background:#f3f4f6;
      color:#111827;
      transition: transform .04s ease, filter .15s ease, opacity .2s ease;
      user-select:none;
    }
    button:active{ transform: scale(.98); }
    button.primary{ background: #2563eb; color:#fff; }
    button.danger{ background:#fee2e2; color:#991b1b; }

    .qRowUnder{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 12px;
      margin: 8px 0 10px;
      flex-wrap:wrap;
    }
    .qLabel{
      font-weight: 950;
      color: var(--ink);
      font-size: 16px;
      white-space: nowrap;
    }
    .qBox{
      border: 2px solid #111827;
      border-radius: 16px;
      padding: 10px 14px;
      font-weight: 950;
      font-size: 26px;
      letter-spacing: .2px;
      background:#fff;
      min-width: 240px;
      text-align:center;
      line-height: 1.15;
    }

    .qLine{ display:block; margin: 0; }
    .qLine.small{
      margin-top: 8px;
      font-size: 22px;
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity .18s ease, transform .18s ease;
      font-weight: 950;
    }
    .qLine.small.show{
      opacity: 1;
      transform: translateY(0);
    }

    .hl{
      background: var(--hi);
      border-radius: 10px;
      padding: 2px 6px;
      display:inline-block;
    }
    .eq{ color: var(--eq); font-weight: 950; }

    .ansPill{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(37,99,235,.18);
      color: var(--eq);
      font-weight: 950;
      border: 2px solid transparent;
    }
    /* final reveal styling */
    .ansPill.final{
      background: rgba(22,163,74,.18);
      color: #0f5132;
      border-color: rgba(22,163,74,.28);
      font-size: 1.12em;
      padding: 2px 10px;
    }

    .stage{
      margin-top: 8px;
      padding: 12px 12px 18px;
      border-radius: 16px;
      background: linear-gradient(180deg,#ffffff, #f9fafb);
      border: 1px solid #e5e7eb;
      overflow:hidden;
      position: relative;
      min-height: 540px;
    }

    .svgwrap{ width:100%; height: 440px; display:block; }

    .personLayer{
      position:absolute;
      left:0; top:0; right:0; bottom:0;
      pointer-events:none;
    }
    .person{
      position:absolute;
      width: 92px;              /* üëà easiest place to experiment (change this number) */
      height: auto;
      transform: translate(-50%, -50%);
      top: 120px; /* moved up a bit to reduce clash with arrow 2 */
      left: 50%;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.12));
    }

    .stageActions{
      position: absolute;
      left: 14px;
      right: 14px;
      bottom: 14px;
      display:flex;
      justify-content:center;
      gap: 18px;
      pointer-events:none;
    }
    .navBtn{
      pointer-events:auto;
      border-radius: 999px;
      padding: 12px 18px;
      font-weight: 950;
      box-shadow: 0 12px 24px rgba(0,0,0,.10);
      min-width: 60px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
    }
    .navBtn[disabled]{ opacity: .45; cursor:not-allowed; transform:none; }

    .hintRow{
      margin-top: 10px;
      text-align:center;
      font-size: 12px;
      color: var(--muted);
      font-weight: 850;
    }

    .mmtFooter{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      height: var(--footer-h);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 12px;
      background: rgba(255,255,255,.92);
      border-top: 1px solid rgba(229,231,235,.95);
      backdrop-filter: blur(8px);
      z-index: 500;
      font-weight: 900;
      color: #111827;
      text-align:center;
      font-size: 13px;
    }
    .mmtFooter a{ color: #2563eb; text-decoration:none; font-weight: 950; }
    .mmtFooter a:hover{ text-decoration: underline; }

    .baseline{ stroke: var(--line); stroke-width: 7; stroke-linecap: round; }
    .tickMajor{ stroke: var(--tick); stroke-width: 7; stroke-linecap: round; }
    .tickUnit{
      stroke: rgba(17,24,39,.40);
      stroke-width: 3;
      stroke-linecap: round;
      opacity: 1;
    }

    .dot{ fill: #111827; opacity: 0.92; }
    .dot.zero{ opacity: 0.85; }

    .label{
      font-size: 26px;
      font-weight: 950;
      fill: #111827;
    }

    .arrowPath{
      fill: none;
      stroke-width: var(--arrowW);
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: var(--dash) var(--gap);
    }
    .arrowLabel{
      font-size: 30px;
      font-weight: 950;
    }

    .trackerDot{
      fill: #111827;
      opacity: 0;
      transition: opacity .12s ease;
    }

    /* number line answer highlight (hidden until final reveal) */
    .ansHalo{
      fill: var(--okSoft);
      stroke: rgba(22,163,74,.35);
      stroke-width: 3;
      display:none;
    }
    .ansGlowDot{
      fill: rgba(22,163,74,.9);
      opacity: .14;
      display:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <a class="brandBack" href="https://www.millsmathstools.au" aria-label="Back to Mills Maths Tools">
          <img src="mmt.png" alt="MMT logo">
          <span>Back to Mills Maths Tools</span>
        </a>

        <div class="btnrow">
          <button id="resetBtn" class="danger" title="Reset (R)">Reset</button>
          <button id="newBtn" class="primary" title="New question (Space)">New Q</button>
        </div>
      </div>

      <div class="qRowUnder" aria-label="Question">
        <div class="qLabel">Question:</div>
        <div id="qBox" class="qBox">
          <span id="qMain" class="qLine">‚Äî</span>
          <span id="qSimpl" class="qLine small">‚Äî</span>
        </div>
      </div>

      <div class="stage">
        <svg id="svg" class="svgwrap" viewBox="0 0 1000 440" role="img" aria-label="number line"></svg>

        <div class="personLayer">
          <img id="personImg" class="person" src="still.png" alt="person">
        </div>

        <div class="stageActions">
          <button id="backBtn" class="navBtn" title="Back (‚Üê)" aria-label="Back">‚óÄ</button>
          <button id="fwdBtn" class="navBtn primary" title="Forward (‚Üí / Enter)" aria-label="Forward">‚ñ∂</button>
        </div>
      </div>

      <div class="hintRow">
        Shortcuts: ‚Üê / ‚Üí step ¬∑ Enter = skip/next ¬∑ Space = New Q ¬∑ R = Reset
      </div>
    </div>
  </div>

  <div class="mmtFooter">
    This tool and more can be found at&nbsp;
    <a href="https://www.millsmathstools.au">www.millsmathstools.au</a>
  </div>

<script>
(() => {
  const MIN = -20;
  const MAX =  20;
  const PAD =  3;

  const ANIM_MS = 2000;

  const SPRITES = {
    still: "still.png",
    right: ["walk-right-1.png", "walk-right-2.png"],
    left:  ["walk-left-1.png",  "walk-left-2.png"]
  };

  const svg = document.getElementById("svg");
  const qMain = document.getElementById("qMain");
  const qSimpl = document.getElementById("qSimpl");

  const personImg = document.getElementById("personImg");

  const newBtn = document.getElementById("newBtn");
  const resetBtn = document.getElementById("resetBtn");
  const backBtn = document.getElementById("backBtn");
  const fwdBtn  = document.getElementById("fwdBtn");

  const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const abs = Math.abs;
  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

  function nonZeroRand(min,max){
    for (let i=0;i<2000;i++){
      const v = randInt(min,max);
      if (v !== 0) return v;
    }
    return 1;
  }

  function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

  function el(name, attrs={}, children=[]){
    const n = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
    for (const c of children) n.appendChild(c);
    return n;
  }
  function textNode(str, attrs={}){
    const t = el("text", attrs);
    t.textContent = str;
    return t;
  }

  function fmtSignedVector(n){
    return (n < 0) ? String(n) : String(abs(n));
  }

  function questionHTML(a, op, b, highlightPart){
    const opChar = (op === "+") ? "+" : "‚àí";
    const aStr = String(a);
    const bStr = (b < 0) ? `(${b})` : `(+${b})`;
    const wrap = (txt, which) => (highlightPart === which) ? `<span class="hl">${txt}</span>` : txt;
    return `${wrap(aStr,"a")} ${wrap(opChar,"op")} ${wrap(bStr,"b")}`;
  }

  function simplifiedLine(a, op, b, res, finalPill=false){
    let cleanOp = op;
    let cleanB  = b;

    if (op === "+" && b < 0){
      cleanOp = "-";
      cleanB  = abs(b);
    } else if (op === "-"){
      if (b < 0){
        cleanOp = "+";
        cleanB  = abs(b);
      } else {
        cleanOp = "-";
        cleanB  = b;
      }
    } else if (op === "+" && b > 0){
      cleanOp = "+";
      cleanB  = b;
    }

    const opChar = (cleanOp === "+") ? "+" : "‚àí";
    const pillClass = finalPill ? "ansPill final" : "ansPill";
    return `${a} ${opChar} ${cleanB} = <span class="${pillClass}">${res}</span>`;
  }

  function setPersonStill(){ personImg.src = SPRITES.still; }
  function setPersonStaticFacingByOp(op){
    personImg.src = (op === "+") ? SPRITES.right[0] : SPRITES.left[0];
  }
  function spriteFramesForDirection(dir){
    return (dir === "+") ? SPRITES.right : SPRITES.left;
  }
  function setPersonX(viewX){
    const pct = (viewX / 1000) * 100;
    personImg.style.left = pct + "%";
  }

  let Q = null;
  let stepState = 0; // now 0..4
  let refs = null;

  // ---- Enter-to-skip animation ----
  let isAnimating = false;
  let animToken = null;
  function beginAnimToken(){
    animToken = { skip:false };
    isAnimating = true;
    return animToken;
  }
  function endAnimToken(){
    isAnimating = false;
    animToken = null;
  }
  function requestSkip(){
    if (animToken) animToken.skip = true;
  }

  let walkingTimer = null;
  function stopWalking(){
    if (walkingTimer) { clearInterval(walkingTimer); walkingTimer = null; }
  }
  function startWalking(spriteDir){
    stopWalking();
    const frames = spriteFramesForDirection(spriteDir);
    let i = 0;
    personImg.src = frames[0];
    walkingTimer = setInterval(() => {
      i = (i + 1) % frames.length;
      personImg.src = frames[i];
    }, 220);
  }

  function generateQuestion(){
    for (let tries=0; tries<5000; tries++){
      const a = nonZeroRand(MIN, MAX);
      const b = nonZeroRand(MIN, MAX);
      const op = (Math.random() < 0.5) ? "+" : "-";
      const res = (op === "+") ? (a + b) : (a - b);
      if (res < MIN || res > MAX) continue;
      return { a, b, op, res };
    }
    return { a: 5, b: -3, op: "+", res: 2 };
  }

  function computeViewRange(a, res){
    const lo = Math.min(0, a, res) - PAD;
    const hi = Math.max(0, a, res) + PAD;
    return { vmin: clamp(lo, MIN, MAX), vmax: clamp(hi, MIN, MAX) };
  }

  function buildScene(){
    clearSVG();
    refs = null;

    const { a, b, op, res } = Q;
    const { vmin, vmax } = computeViewRange(a, res);

    const left = 80, right = 920;

    const yLine = 325;
    const tickTop = yLine - 22;
    const yArrow1 = tickTop - 42;
    const yArrow2 = yArrow1 - 58; // leave as master

    const tickBot = yLine + 22;
    const dotR = 10;
    const labelY = 405;

    const x = (v) => {
      const t = (v - vmin) / (vmax - vmin);
      return left + t * (right - left);
    };

    const defs = el("defs");

    // end marker (points along the path direction)
    const mkEnd = el("marker",{
      id:"arrowHeadSmall",
      markerWidth:"6",
      markerHeight:"6",
      refX:"6",
      refY:"3",
      orient:"auto",
      markerUnits:"strokeWidth",
      viewBox:"0 0 6 6"
    },[
      el("path",{ d:"M 0 0 L 6 3 L 0 6 z", fill:"currentColor" })
    ]);

    // start marker (FLIPPED so it points opposite)
    const mkStart = el("marker",{
      id:"arrowHeadStart",
      markerWidth:"6",
      markerHeight:"6",
      refX:"0",
      refY:"3",
      orient:"auto",
      markerUnits:"strokeWidth",
      viewBox:"0 0 6 6"
    },[
      el("path",{ d:"M 6 0 L 0 3 L 6 6 z", fill:"currentColor" })
    ]);

    defs.appendChild(mkEnd);
    defs.appendChild(mkStart);
    svg.appendChild(defs);

    svg.appendChild(el("line", { x1:left, y1:yLine, x2:right, y2:yLine, class:"baseline" }));

    const gTicks = el("g");
    const gUnit  = el("g");
    const gArrows= el("g");
    const gHL    = el("g"); // highlights

    function addMajor(val, dotClass){
      const xi = x(val);
      gTicks.appendChild(el("line",{ x1:xi, y1:tickTop, x2:xi, y2:tickBot, class:"tickMajor" }));
      gTicks.appendChild(el("circle",{ cx:xi, cy:yLine, r:dotR, class:`dot ${dotClass||""}`.trim() }));
      gTicks.appendChild(textNode(String(val), { x:xi, y:labelY, "text-anchor":"middle", class:"label" }));
      return { x: xi, val };
    }

    for (let v = Math.ceil(vmin); v <= Math.floor(vmax); v++){
      if (v === 0) continue;
      const xi = x(v);
      gUnit.appendChild(el("line", { x1:xi, y1:yLine-12, x2:xi, y2:yLine+12, class:"tickUnit" }));
    }

    svg.appendChild(gUnit);
    svg.appendChild(gHL);
    svg.appendChild(gTicks);

    addMajor(0, "zero");

    function makeArrow(x1, x2, y, color, labelText, headSide="end"){
      const attrs = { x1, y1:y, x2:x1, y2:y, class:"arrowPath" };
      if (headSide === "start") attrs["marker-start"] = "url(#arrowHeadStart)";
      else attrs["marker-end"] = "url(#arrowHeadSmall)";

      const path = el("line", attrs);
      path.style.stroke = color;
      path.style.color  = color;
      path.style.display = "none";

      const lx = (x1 + x2) / 2;
      const ly = y - 18;
      const label = textNode(labelText, { x:lx, y:ly, "text-anchor":"middle", class:"arrowLabel" });
      label.style.fill = color;
      label.style.display = "none";

      const tip = el("circle",{ cx:x1, cy:y, r:"6", class:"trackerDot" });
      tip.style.display = "none";

      gArrows.appendChild(path);
      gArrows.appendChild(label);
      gArrows.appendChild(tip);

      return { path, label, tip, x1, x2, y, color, headSide };
    }

    const x0 = x(0);
    const xA = x(a);
    const xR = x(res);

    const colA = (a >= 0) ? "var(--pos)" : "var(--neg)";
    const colB = (b >= 0) ? "var(--pos)" : "var(--neg)";

    const disp2 = (op === "+") ? b : -b;
    const xEnd2 = x(a + disp2);

    const arrowA = makeArrow(x0, xA, yArrow1, colA, fmtSignedVector(a), "end");

    // subtraction ALWAYS reverses the arrowhead (walk back along the vector)
    const headSideB = (op === "-") ? "start" : "end";
    const arrowB = makeArrow(xA, xEnd2, yArrow2, colB, fmtSignedVector(b), headSideB);

    svg.appendChild(gArrows);

    addMajor(a, "");
    addMajor(res, "");

    // result highlight on number line (HIDDEN until final reveal)
    const resHalo = el("circle", { cx:xR, cy:labelY-16, r:"22", class:"ansHalo" });
    const resGlowDot = el("circle", { cx:xR, cy:yLine, r:"22", class:"ansGlowDot" });
    gHL.appendChild(resGlowDot);
    gHL.appendChild(resHalo);

    const tickNodes = Array.from(gTicks.childNodes);
    for (let i=3; i<tickNodes.length; i++){
      tickNodes[i].style.display = "none";
    }

    refs = {
      x0, xA, xR,
      arrowA, arrowB,
      tickNodes,
      resHalo,
      resGlowDot,
      showA: () => { for (let i=3; i<6; i++) tickNodes[i].style.display = ""; },
      showRes: () => { for (let i=6; i<9; i++) tickNodes[i].style.display = ""; },
      showResHighlight: () => { refs.resHalo.style.display = ""; refs.resGlowDot.style.display = ""; },
      hideResHighlight: () => { refs.resHalo.style.display = "none"; refs.resGlowDot.style.display = "none"; }
    };

    refs.hideResHighlight();
    setPersonX(x0);
  }

  function showArrowLabel(arrow){ arrow.label.style.display = ""; }
  function hideArrow(arrow){
    arrow.path.style.display = "none";
    arrow.label.style.display = "none";
    arrow.tip.style.display = "none";
    arrow.tip.style.opacity = "0";
  }

  function snapArrowToEnd(arrow){
    const { path, tip, x1, x2, y } = arrow;
    path.style.display = "";
    tip.style.display  = "";
    tip.style.opacity  = "1";
    path.setAttribute("x1", String(x1));
    path.setAttribute("y1", String(y));
    path.setAttribute("x2", String(x2));
    path.setAttribute("y2", String(y));
    tip.setAttribute("cx", String(x2));
    tip.setAttribute("cy", String(y));
  }

  function animateLineArrow(arrow, durationMs, token){
    return new Promise((resolve) => {
      const { path, tip, x1, x2, y } = arrow;

      path.style.display = "";
      tip.style.display  = "";
      tip.style.opacity  = "1";

      const start = performance.now();

      function frame(now){
        if (token && token.skip){
          snapArrowToEnd(arrow);
          resolve();
          return;
        }

        const t = clamp((now - start) / durationMs, 0, 1);
        const eased = 1 - Math.pow(1 - t, 2);

        const cx = x1 + (x2 - x1) * eased;

        path.setAttribute("x1", String(x1));
        path.setAttribute("y1", String(y));
        path.setAttribute("x2", String(cx));
        path.setAttribute("y2", String(y));

        tip.setAttribute("cx", String(cx));
        tip.setAttribute("cy", String(y));

        if (t < 1){
          requestAnimationFrame(frame);
        } else {
          snapArrowToEnd(arrow);
          resolve();
        }
      }

      path.setAttribute("x2", String(x1));
      requestAnimationFrame(frame);
    });
  }

  function snapPersonTo(toX){
    stopWalking();
    setPersonX(toX);
    setPersonStill();
  }

  // moveDir controls motion, spriteDir controls which walk frames play.
  function movePerson(fromX, toX, moveDir, spriteDir, durationMs, token){
    return new Promise((resolve) => {
      startWalking(spriteDir);
      const start = performance.now();

      function frame(now){
        if (token && token.skip){
          snapPersonTo(toX);
          resolve();
          return;
        }

        const t = clamp((now - start) / durationMs, 0, 1);
        const eased = 1 - Math.pow(1 - t, 2);
        const cx = fromX + (toX - fromX) * eased;
        setPersonX(cx);

        if (t < 1){
          requestAnimationFrame(frame);
        } else {
          stopWalking();
          setPersonStill();
          resolve();
        }
      }
      requestAnimationFrame(frame);
    });
  }

  function setQuestionText(highlightPart=null){
    const { a, b, op } = Q;
    qMain.innerHTML = questionHTML(a, op, b, highlightPart);
  }

  // final reveal only (step 4) should call this with show=true
  function setSimplified(show){
    const { a, b, op, res } = Q;
    if (!show){
      qSimpl.classList.remove("show");
      qSimpl.innerHTML = "";
      return;
    }
    const pillClass = "ansPill final";
    const orig = `${questionHTML(a, op, b, null)} <span class="eq">= <span class="${pillClass}">${res}</span></span>`;
    qMain.innerHTML = orig;
    qSimpl.innerHTML = simplifiedLine(a, op, b, res, true);
    qSimpl.classList.add("show");
  }

  function updateNavButtons(){
    backBtn.disabled = (stepState <= 0);
    fwdBtn.disabled  = (stepState >= 4);
  }

  function goToStep0(){
    stepState = 0;
    setSimplified(false);
    setQuestionText(null);
    setPersonStill();
    setPersonX(refs.x0);
    hideArrow(refs.arrowA);
    hideArrow(refs.arrowB);

    refs.hideResHighlight();

    for (let i=3; i<refs.tickNodes.length; i++){
      refs.tickNodes[i].style.display = "none";
    }
    updateNavButtons();
  }

  async function doStep1(){
    stepState = 1;
    setSimplified(false);
    setQuestionText("a");
    refs.showA();

    showArrowLabel(refs.arrowA);

    const moveDir1   = (Q.a >= 0) ? "+" : "‚àí";  // movement still depends on sign
    const spriteDir1 = "+";                     // ALWAYS walk-right for first vector

    const token = beginAnimToken();
    try{
      await Promise.all([
        animateLineArrow(refs.arrowA, ANIM_MS, token),
        movePerson(refs.x0, refs.xA, moveDir1, spriteDir1, ANIM_MS, token)
      ]);
    } finally {
      endAnimToken();
    }

    updateNavButtons();
  }

  async function doStep2(){
    stepState = 2;
    setQuestionText("op");
    setPersonStaticFacingByOp(Q.op); // "-" turns left
    updateNavButtons();
  }

  // ‚úÖ Step 3: show/animate second vector + move person, BUT NO ANSWERS/LABELS YET
  async function doStep3(){
    stepState = 3;
    setSimplified(false);
    qSimpl.classList.remove("show");
    setQuestionText("b");

    showArrowLabel(refs.arrowB);
    // IMPORTANT: do NOT show result tick/labels here
    // refs.showRes();  <-- moved to step 4
    refs.hideResHighlight();

    const step2 = (Q.op === "+") ? Q.b : -Q.b;
    const moveDir  = (step2 >= 0) ? "+" : "‚àí";

    // sprite direction depends ONLY on the operator (not the vector)
    const spriteDir = (Q.op === "+") ? "+" : "‚àí";

    const token = beginAnimToken();
    try{
      await Promise.all([
        animateLineArrow(refs.arrowB, ANIM_MS, token),
        movePerson(refs.xA, refs.xR, moveDir, spriteDir, ANIM_MS, token)
      ]);
    } finally {
      endAnimToken();
    }

    updateNavButtons();
  }

  // ‚úÖ Step 4: reveal ALL answers (box + number line label/highlight)
  function doStep4(){
    stepState = 4;

    // reveal result tick/label and highlight on the number line
    refs.showRes();
    refs.showResHighlight();

    // reveal top answers/simplified line
    setSimplified(true);

    updateNavButtons();
  }

  async function stepForward(){
    if (stepState >= 4) return;
    if (stepState === 0) return doStep1();
    if (stepState === 1) return doStep2();
    if (stepState === 2) return doStep3();
    if (stepState === 3) return doStep4();
  }

  function stepBack(){
    if (stepState <= 0) return;
    const target = stepState - 1;

    buildScene();
    goToStep0();

    if (target >= 1){
      setQuestionText("a");
      refs.showA();
      showArrowLabel(refs.arrowA);
      snapArrowToEnd(refs.arrowA);
      setPersonX(refs.xA);
      setPersonStill();
      stepState = 1;
    }
    if (target >= 2){
      setQuestionText("op");
      setPersonStaticFacingByOp(Q.op);
      stepState = 2;
    }
    if (target >= 3){
      // reconstruct step 3 state: second arrow + person at result, but NO answer labels
      setQuestionText("b");
      showArrowLabel(refs.arrowB);
      snapArrowToEnd(refs.arrowB);
      setPersonX(refs.xR);
      setPersonStill();
      refs.hideResHighlight();
      // keep result tick/labels hidden
      for (let i=6; i<9; i++) refs.tickNodes[i].style.display = "none";
      stepState = 3;
    }
    if (target >= 4){
      // step 4 state (shouldn't happen here because target=stepState-1, but safe)
      refs.showRes();
      refs.showResHighlight();
      setSimplified(true);
      stepState = 4;
    }

    // ensure simplified hidden unless we're exactly at step 4
    if (stepState !== 4){
      setSimplified(false);
      qSimpl.classList.remove("show");
    }

    updateNavButtons();
  }

  function newQuestion(){
    Q = generateQuestion();
    buildScene();
    goToStep0();
  }

  function resetQuestion(){
    buildScene();
    goToStep0();
  }

  newBtn.addEventListener("click", () => newQuestion());
  resetBtn.addEventListener("click", () => resetQuestion());
  backBtn.addEventListener("click", () => stepBack());
  fwdBtn.addEventListener("click", () => {
    if (isAnimating) requestSkip();
    else stepForward();
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){
      e.preventDefault();
      if (isAnimating) requestSkip();
      else stepForward();
      return;
    }

    if (e.code === "Space"){ e.preventDefault(); newQuestion(); return; }
    if (e.key === "ArrowRight"){ e.preventDefault(); stepForward(); return; }
    if (e.key === "ArrowLeft"){ e.preventDefault(); stepBack(); return; }
    if (e.key.toLowerCase() === "r"){ e.preventDefault(); resetQuestion(); return; }
  });

  newQuestion();
})();
</script>
</body>
</html>
